# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'autotipworkqt.ui'
#
# Created by: PyQt5 UI code generator 5.15.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys, os
import threading
import time
from PyQt5 import QtCore, QtGui, QtWidgets
from STM import STM
import time
import datetime
import os.path
from open_last import open_last_sts, analyse_last_topo, convert_execute_positions
from normalize import normalize
import sklearn
import joblib
import numpy as np
import matplotlib.pyplot as plt
import sys


def resource_path(relative_path):
    """
    Translate asset paths to useable format for PyInstaller
    """
    if hasattr(sys, '_MEIPASS'):
        return os.path.join(sys._MEIPASS, relative_path)
    return os.path.join(os.path.abspath('.'), relative_path)

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(585, 413)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.start_btn = QtWidgets.QPushButton(self.centralwidget)
        self.start_btn.setObjectName("start_btn")
        self.gridLayout.addWidget(self.start_btn, 1, 1, 1, 1)
        self.start_x_offset = QtWidgets.QLineEdit(self.centralwidget)
        self.start_x_offset.setObjectName("start_x_offset")
        self.gridLayout.addWidget(self.start_x_offset, 0, 1, 1, 1)
        self.start_y_offset = QtWidgets.QLineEdit(self.centralwidget)
        self.start_y_offset.setObjectName("start_y_offset")
        self.gridLayout.addWidget(self.start_y_offset, 0, 5, 1, 1)
        self.start_y_label = QtWidgets.QLabel(self.centralwidget)
        self.start_y_label.setObjectName("start_y_label")
        self.gridLayout.addWidget(self.start_y_label, 0, 4, 1, 1)
        self.stop_btn = QtWidgets.QPushButton(self.centralwidget)
        self.stop_btn.setObjectName("stop_btn")
        self.gridLayout.addWidget(self.stop_btn, 1, 5, 1, 1)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem, 0, 3, 1, 1)
        self.unit_1 = QtWidgets.QLabel(self.centralwidget)
        self.unit_1.setObjectName("unit_1")
        self.gridLayout.addWidget(self.unit_1, 0, 2, 1, 1)
        self.start_x_label = QtWidgets.QLabel(self.centralwidget)
        self.start_x_label.setObjectName("start_x_label")
        self.gridLayout.addWidget(self.start_x_label, 0, 0, 1, 1)
        self.unit_2 = QtWidgets.QLabel(self.centralwidget)
        self.unit_2.setObjectName("unit_2")
        self.gridLayout.addWidget(self.unit_2, 0, 6, 1, 1)
        self.nextwin_btn = QtWidgets.QPushButton(self.centralwidget)
        self.nextwin_btn.setObjectName("nextwin_btn")
        self.gridLayout.addWidget(self.nextwin_btn, 2, 1, 1, 1)
        self.previouswin_btn = QtWidgets.QPushButton(self.centralwidget)
        self.previouswin_btn.setObjectName("previouswin_btn")
        self.gridLayout.addWidget(self.previouswin_btn, 2, 5, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 585, 20))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionExit = QtWidgets.QAction(MainWindow)
        self.actionExit.setObjectName("actionExit")
        self.menuFile.addAction(self.actionExit)
        self.menubar.addAction(self.menuFile.menuAction())

        self.retranslateUi(MainWindow)
        self.initialize()
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Autotipwork"))
        self.start_btn.setStatusTip(_translate("MainWindow", "Start Autotipwork"))
        self.start_btn.setText(_translate("MainWindow", "Start"))
        self.start_y_label.setText(_translate("MainWindow", "Start Y Offset"))
        self.stop_btn.setStatusTip(_translate("MainWindow", "Stop Autotipwork"))
        self.stop_btn.setText(_translate("MainWindow", "Stop"))
        self.unit_1.setText(_translate("MainWindow", "nm"))
        self.start_x_label.setText(_translate("MainWindow", "Start X Offset"))
        self.unit_2.setText(_translate("MainWindow", "nm"))
        self.nextwin_btn.setStatusTip(_translate("MainWindow", "Go to the next scan window"))
        self.nextwin_btn.setText(_translate("MainWindow", "Next Scan Window"))
        self.previouswin_btn.setStatusTip(_translate("MainWindow", "Go to the Previous Scan Window"))
        self.previouswin_btn.setText(_translate("MainWindow", "Previous Scan Window"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.actionExit.setText(_translate("MainWindow", "Exit"))
        self.actionExit.setStatusTip(_translate("MainWindow", "Stop and Exit Program"))
        self.actionExit.setShortcut(_translate("MainWindow", "Ctrl+Q"))

    def initialize(self):
        MainWindow.setWindowIcon(QtGui.QIcon(resource_path('autotipworklogo.png')))

        self.stop_main_program = threading.Event()
        self.stop_scanning = threading.Event()

        self.my_stm = STM()

        self.start_x_offset.setText("-800")
        self.start_y_offset.setText("800")
        self.start_btn.clicked.connect(self.start_program)
        self.stop_btn.clicked.connect(self.stop_program)
        self.actionExit.triggered.connect(self.exit_program)
        self.nextwin_btn.clicked.connect(self.next_win)
        self.previouswin_btn.clicked.connect(self.previous_win)

    def auto_tipwork(self):
        def operate(operation, record_file):
            operation_time = str(datetime.datetime.now().time())
            print(operation_time)
            print(operation)
            with open(record_file, 'a') as file:
                file.write(operation_time + '\n' + operation + '\n')

        start_x = int(self.start_x_position)
        start_y = int(self.start_y_position)
        
        ml_model = joblib.load('ml_model_ada.pkl')

        record_file_path = './operation_record'
        today = datetime.date.today()
        record_file_name = record_file_path + '/' + str(today) + '.txt'
        if not os.path.isfile(record_file_name):
            with open(record_file_name, 'w') as file:
                pass

        operate(self.my_stm.init(), record_file_name)
        positions = []
        head = self.my_stm.get_head_file()
        rawdata_path = self.my_stm.get_file_path()

        if not start_y%100 == 0:
            if start_y > 0:
                start_y = int(start_y/100)*100
            else:
                start_y = (int(start_y/100)-1)*100

        if (start_y/100)%2 == 0:
            if not start_x%100 == 0:
                if start_x > 0:
                    start_x = (int(start_x/100)+1)*100
                else:
                    start_x = int(start_x/100)*100

            for x in range(start_x, 800+100, 100):
                positions.append([x, start_y])

        else:
            if not start_x%100 == 0:
                if start_x > 0:
                    start_x = int(start_x/100)*100
                else:
                    start_x = (int(start_x/100)-1)*100
            for x in range(start_x, -800-100, -100):
                positions.append([x, start_y])

        for y in range(start_y-100, -800-100, -100):
            if (y/100)%2 == 0:
                for x in range(-800, 800+100, 100):
                    positions.append([x, y])
            else:
                for x in range(800, -800-100, -100):
                    positions.append([x, y])

        #print(positions)
        operate(self.my_stm.set_xy_offset(positions[0][0], positions[0][1]), record_file_name)
        if self.stop_main_program.wait(timeout = 70):
            operate(self.my_stm.rundown(), record_file_name)
            return
        last_spectra_good = False
        for position in positions:
            operate(self.my_stm.set_xy_offset(position[0], position[1]), record_file_name)
            if self.stop_main_program.wait(timeout = 10):
                break
            
            self.t_scan = threading.Thread(target = self.scanning_standby, daemon = True)
            self.stop_scanning.clear()
            self.t_scan.start()
            
            operate(self.my_stm.start(), record_file_name)
            operate(self.my_stm.monitor_zout(), record_file_name)
            operate(self.my_stm.stop(), record_file_name)

            self.t_scan.join()
            
            if self.stop_main_program.wait(timeout = 1):
                break
            #execute_positions = analyse_last_topo('D:/LUCILE_rawdata/Dropbox/LUCILE_rawdata', head)
            execute_positions = analyse_last_topo(rawdata_path, head)

            points, lines = self.my_stm.get_points_lines()
            execute_positions = convert_execute_positions(execute_positions, points, lines)
            print(execute_positions)
            for execute_position in execute_positions:
                if self.stop_main_program.is_set():
                    break
                operate(self.my_stm.set_execute_port_colour(), record_file_name)
                operate(self.my_stm.enable_VExt(), record_file_name)
                operate(self.my_stm.set_target_position(execute_position[0], execute_position[1]), record_file_name)
                operate(self.my_stm.save_aux2v(False), record_file_name)
                operate(self.my_stm.move_tip(), record_file_name)
                if self.stop_main_program.wait(timeout = 120):
                    break
                operate(self.my_stm.save_aux2v(True), record_file_name)
                operate(self.my_stm.move_tip(), record_file_name)
                if self.stop_main_program.wait(timeout = 120):
                    break
                operate(self.my_stm.disable_VExt(), record_file_name)
                V, didv = open_last_sts(rawdata_path, head)
                #if V == None or didv == None:
                #    operate('STS curve is not saved', record_file_name)
                #    operate(self.my_stm.pull_tip_back(), record_file_name)
                #    operate(self.my_stm.rundown(), record_file_name)
                #    sys.exit(0)
                #V, didv = standardize_curve(V, didv)
                # The Norm for the Standardizing the Curve Has Also Changed


                #V, didv = standardize_curve(V, didv, -1, 1, search_win_min = -0.75, search_win_max = 0)
                V, didv, sf = normalize(V, didv)

                didv = np.reshape(didv, (1,-1))
                #result = ml_model.predict(didv)
                # WARNING: threshold is tuned for each model. Must change when change model.
                model_threshold = 0.5
                result = ml_model.decision_function(didv) >= model_threshold
                print(result)
                if result[0]:
                    if last_spectra_good:
                        time.sleep(5)
                        #operate(self.my_stm.pull_tip_back(), record_file_name)
                        operate(self.my_stm.rundown(), record_file_name)
                        sys.exit(0)
                    else:
                        last_spectra_good = True
                        continue
                else:
                    last_spectra_good = False
                    operate(self.my_stm.disable_VExt(), record_file_name)
                    operate(self.my_stm.set_zramp(), record_file_name)
                    operate(self.my_stm.move_tip(), record_file_name)
                    if self.stop_main_program.wait(timeout = 20):
                        continue

            if self.stop_main_program.is_set():
                break
        operate(self.my_stm.rundown(), record_file_name)

    def start_program(self):
        self.t0 = threading.Thread(target = self.auto_tipwork, daemon = True)
        self.start_x_position = self.start_x_offset.text()
        self.start_y_position = self.start_y_offset.text()
        try:
            self.start_x_position = int(self.start_x_position)
            self.start_y_position = int(self.start_y_position)
            if self.start_x_position<=800 and\
               self.start_x_position>=-800 and\
               self.start_y_position<=800 and\
               self.start_y_position>=-800:
                self.stop_main_program.clear()
                self.t0.start()
            else:
                alert = QtWidgets.QMessageBox(self.centralwidget)
                alert.setWindowTitle('Start Positions Error')
                alert.setText('Start Positions must be numbers between -800 to 800.')
                alert.exec_()
        except ValueError:
            alert = QtWidgets.QMessageBox(self.centralwidget)
            alert.setWindowTitle('Start Positions Error')
            alert.setText('Start Positions must be numbers between -800 to 800.')
            alert.exec_()

    def scanning_standby(self):
        scan_time = self.my_stm.scan_time()
        if self.stop_scanning.wait(timeout = scan_time + 1):
            rs = self.my_stm.stop()

    def stop_program(self):
        """
        Stop AutoTipWork
        """
        if not self.stop_main_program.is_set():
            choice = QtWidgets.QMessageBox.question(self.centralwidget, 'Stop AutoTipWork',
                                                    'Stop AutoTipWork?',
                                                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
            if choice == QtWidgets.QMessageBox.Yes:
                self.stop_main_program.set()
                self.stop_scanning.set()
                self.t0.join()
                alert = QtWidgets.QMessageBox(self.centralwidget)
                alert.setWindowTitle('Stop AutoTipWork')
                alert.setText('AutoTipWork has been stopped!')
                alert.exec_()
            else:
                pass
        else:
            alert = QtWidgets.QMessageBox(self.centralwidget)
            alert.setWindowTitle('Stop AutoTipWork')
            alert.setText('AutoTipWork is not running!')
            alert.exec_()

    def exit_program(self):
        """
        Stop AutoTipWork and exit program
        """
        choice = QtWidgets.QMessageBox.question(self.centralwidget, 'Stop AutoTipWork',
                                                'Stop AutoTipWork?',
                                                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        if choice == QtWidgets.QMessageBox.Yes:
            self.stop_main_program.set()
            self.stop_scanning.set()
            self.t0.join()
            alert = QtWidgets.QMessageBox(self.centralwidget)
            alert.setWindowTitle('Stop AutoTipWork')
            alert.setText('AutoTipWork has been stopped!')
            alert.exec_()
            sys.exit()
        else:
            pass

    def next_win(self):
        """
        Set the start X, Y position to the next window
        """
        self.start_x_position = self.start_x_offset.text()
        self.start_y_position = self.start_y_offset.text()
        try:
            self.start_x_position = int(self.start_x_position)
            self.start_y_position = int(self.start_y_position)
            if self.start_x_position<=800 and\
               self.start_x_position>=-800 and\
               self.start_y_position<=800 and\
               self.start_y_position>=-800:
                start_x = self.start_x_position
                start_y = self.start_y_position
                next_x = -1000
                next_y = -1000

                if not start_y%100 == 0:
                    if start_y > 0:
                        start_y = int(start_y/100)*100
                    else:
                        start_y = (int(start_y/100)-1)*100

                if (start_y/100)%2 == 0:
                    if not start_x%100 == 0:
                        if start_x > 0:
                            start_x = (int(start_x/100)+1)*100
                        else:
                            start_x = int(start_x/100)*100

                    if start_x == 800:
                        next_x = 800
                        next_y = start_y - 100
                    else:
                        next_x = start_x + 100
                        next_y = start_y

                else:
                    if not start_x%100 == 0:
                        if start_x > 0:
                            start_x = int(start_x/100)*100
                        else:
                            start_x = (int(start_x/100)-1)*100

                    if start_x == -800:
                        next_x = -800
                        next_y = start_y - 100
                    else:
                        next_x = start_x - 100
                        next_y = start_y

                if next_y < -800:
                    alert = QtWidgets.QMessageBox(self.centralwidget)
                    alert.setWindowTitle('Start Positions Error')
                    alert.setText("This is the last window in this area. Move macroscopically to a new area")
                    alert.exec_()
                else:
                    self.start_x_offset.setText(str(next_x))
                    self.start_y_offset.setText(str(next_y))
            else:
                alert = QtWidgets.QMessageBox(self.centralwidget)
                alert.setWindowTitle('Start Positions Error')
                alert.setText('Start Positions must be numbers between -800 to 800.')
                alert.exec_()
        except ValueError:
            alert = QtWidgets.QMessageBox(self.centralwidget)
            alert.setWindowTitle('Start Positions Error')
            alert.setText('Start Positions must be numbers between -800 to 800.')
            alert.exec_()

    def previous_win(self):
        """
        Set the start X, Y position to the next window
        """
        self.start_x_position = self.start_x_offset.text()
        self.start_y_position = self.start_y_offset.text()
        try:
            self.start_x_position = int(self.start_x_position)
            self.start_y_position = int(self.start_y_position)
            if self.start_x_position<=800 and\
               self.start_x_position>=-800 and\
               self.start_y_position<=800 and\
               self.start_y_position>=-800:
                start_x = self.start_x_position
                start_y = self.start_y_position
                previous_x = -1000
                previous_y = -1000

                if not start_y%100 == 0:
                    if start_y > 0:
                        start_y = int(start_y/100)*100
                    else:
                        start_y = (int(start_y/100)-1)*100

                if (start_y/100)%2 == 0:
                    if not start_x%100 == 0:
                        if start_x > 0:
                            start_x = (int(start_x/100)+1)*100
                        else:
                            start_x = int(start_x/100)*100

                    if start_x == -800:
                        previous_x = -800
                        previous_y = start_y + 100
                    else:
                        previous_x = start_x - 100
                        previous_y = start_y

                else:
                    if not start_x%100 == 0:
                        if start_x > 0:
                            start_x = int(start_x/100)*100
                        else:
                            start_x = (int(start_x/100)-1)*100

                    if start_x == 800:
                        previous_x = 800
                        previous_y = start_y + 100
                    else:
                        previous_x = start_x + 100
                        previous_y = start_y

                if previous_y > 800:
                    alert = QtWidgets.QMessageBox(self.centralwidget)
                    alert.setWindowTitle('Start Positions Error')
                    alert.setText("This is the first window in this area. Try next window or move macroscopically to a new area")
                    alert.exec_()
                else:
                    self.start_x_offset.setText(str(previous_x))
                    self.start_y_offset.setText(str(previous_y))
            else:
                alert = QtWidgets.QMessageBox(self.centralwidget)
                alert.setWindowTitle('Start Positions Error')
                alert.setText('Start Positions must be numbers between -800 to 800.')
                alert.exec_()
        except ValueError:
            alert = QtWidgets.QMessageBox(self.centralwidget)
            alert.setWindowTitle('Start Positions Error')
            alert.setText('Start Positions must be numbers between -800 to 800.')
            alert.exec_()



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
